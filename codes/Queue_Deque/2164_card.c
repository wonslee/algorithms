/*
 * N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번
카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.

이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에
있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드
밑으로 옮긴다.

예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로
놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을
버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는
카드는 4가 된다.

N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.

출력
첫째 줄에 남게 되는 카드의 번호를 출력한다.


# 문제접근
가장 앞 index와 가장 뒤 index가 핵심!
배열과 pointer(index) 2개가 있으면 될 것. queue!

Queue ADT
데이터
front는 맨앞원소의 한 칸 앞을 가리킨다. 초기에 -1.
rear은 맨 뒤 원소를 가리킴

초기 조건: front = rear = -1
공백 조건: front = rear
하나만 남아있을 조건: rear-front = 1

연산
isEmpty()는 필요 없음. 마지막 원소가 남을 때 끝이니까.

enqueue(int item): item을 큐의 rear 뒷 index에 삽입
    queue[++rear] = item

dequeue_twice(): 한번에 원소 2개 삭제후 2번째 삭제된 원소 반환
    여기선 일반적인 dequeue 대신 이게 효율적이다.

여기선 원소가 딱 하나만 남아있는지 체크하는 로직이 필요.
하나만 남아있다면, 그 원소를 출력.
1. loop: N만큼 반복. i=1
    1-1. i~N을 배열에 삽입.
2. loop: N-1만큼(원소가 하나만 남아있을 때까지) 반복
    2-1. dequeue
    2-2. dequeue, 반환 값 저장
    2-3. 2-2의 값을 enqueue
3. printf : 마지막 남은 원소

주의점
- 맨 뒤에 계속해서 push를 하므로,
추상적으로 보면 카드 개수가 같지만 큐의 index는 계속해서 뒤로 늘어난다. (배열의
한계) 배열의 사이즈는 (N-1) *2 가 되어야 함.

배운점
- 짜야하는 알고리즘에 따라, 원래의 ADT 연산을 다르게 변형시키는게 유리할 때가 있다. 원래라면 dequeue가 하나의 원소만 삭제했지만, 여기선 불필요한 반복이 되므로 한 번에 2개 원소를 삭제하는 연산을 구현했다.
- 우선순위 큐 하다가 큐로 넘어오니까 꽤 간단해보인다. index만 제대로 신경쓰면.
- 원형 큐로 하면 배열에 필요한 메모리 공간을 거의 절반으로 줄일 수 있다! (출처 https://blog.naver.com/kim-nan-hee/221901814483)
*/
#include <stdio.h>

int queue[1000000];
int front = -1;
int rear = -1;

// enqueue
void enqueue(int item) { queue[++rear] = item; }
// dequeue_twice: 한번에 원소 2개 삭제후 2번째 삭제된 원소 반환
int dequeue_twice() {
  front += 2;
  return queue[front];
}

int main() {
  int n;
  scanf("%i", &n);
  // 카드 배열 만들기
  for (int i = 1; i <= n; i++) enqueue(i);

  // 원소가 하나만 남을때까지 반복 (N-1회)
  while (rear - front != 1) enqueue(dequeue_twice());

  printf("%i\n", queue[rear]);
}
