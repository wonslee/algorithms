/*
 *
라우터 내부를 들여다보면 처리해야 할 패킷을 임시적으로 보관하기 위한 버퍼가
존재한다. 이 버퍼에는 라우터에 입력으로 들어온 패킷들이 순서대로 위치하고,
라우터에서는 먼저 온 패킷부터 하나씩 처리한 후 버퍼에서 제거한다. 만약 라우터가
패킷을 처리하는 속도보다 패킷이 들어오는 속도가 더 빠를경우 버퍼가 꽉 차거나
넘쳐버릴 것이다. 그렇게 되면 버퍼에 공간이 생길 때까지 입력받는 패킷은 모두
버려진다.

입력
첫 줄에는 라우터 내부에 존재하는 버퍼의 크기를 나타내는 자연수 N이 주어진다.

둘째 줄부터 한 줄에 하나씩 라우터가 처리해야 할 정보가 주어진다. 모든 정보는
발생한 시간순으로 주어졌다고 가정한다. 양의 정수는 해당하는 번호의 패킷이
입력으로 들어왔다는 것을 의미하고, 0은 라우터가 패킷 하나를 처리했다는 것을
의미한다. 이때, 버퍼가 비어있을때는 0이 입력으로 들어오지 않는다. -1은 입력의
끝을 나타낸다.

출력
라우터에 남아있는 패킷을 앞에서부터 순서대로 공백으로 구분해서 출력하면 된다.
만약 비어있을 경우 empty라고 출력한다.
*/
/*
# 문제접근
'입력으로 들어온 패킷들이 순서대로 위치', '먼저 온 패킷부터 처리 후 제거'
==> 큐 자료구조!
데이터:
queue[N],
front, rear
초기조건: front=rear=-1
공백조건: front=rear
포화조건: rear=N-1

isEmpty()
isFull()
enqueue(int item):
포화가 아닐 경우에, ++rear번째에 삽입
dequeue():
공백이 아닐 경우에, ++front번째를 반환

1. loop: N만큼 반복
1-1. scanf input
1-2. 양의 정수일 경우: enqueue(input)
1-3. 0일 경우: dequeue
2. 마지막에 남아있는 원소들 출력. 비어있다면 empty 출력

주의점
- 큐의 포화조건을 그대로 써선 안 된다. 버퍼의 사이즈 = rear - front 를 이용하자.
- 혹시 100점을 못 받은게 사이즈 때문이었다.. 200000으로 늘려주니 해결. 왜지?
*/
#include <stdio.h>

int queue[130000];
int front = -1;
int rear = -1;

int main() {
  int n;
  scanf("%i", &n);

  while (1) {
    int input;
    scanf("%i", &input);

    if (input == -1) break;
    // 0일 경우 dequeue. 문제조건중에 비어있을 땐 0이 입력으로 들어오지 않으므로
    // 공백상태 검사는 생략.
    else if (input == 0) ++front;
    // 양의 정수이고 '버퍼'가 포화 상태가 아닐 경우, enqueue.
    else{
        if (rear - front < n) queue[++rear] = input;
    } 
  }

  // 모든 원소 출력. 비어있을 경우 empty 출력
  if (front == rear)
    printf("empty");
  else
    for (int i = front + 1; i < rear + 1; i++)
      printf("%i\n", queue[i]);

  return 0;
}
