/*
# 문제 재정의
    쉬운 계단수 문제와 비슷해보인다.
    각 자릿수에 대해 올 수 있는 수를 2차원 배열로 저장해서 조건문에 따라 저장하는 로직.
# 계획
 d[3]의 경우, d[2]에서 봤던 10이 반복되어 나오고 0으로 끝나는 부분에서 0,1로 나뉘어진다.
 d[4]의 경우, 마찬가지로 d[3]에서 연장되지만, 11을 부분으로 가질 수 없다는 규칙 때문에 1011 등이 나오지 않는다.

 - 이전 자리의 0 개수 * 2 + 이전 자리의 1 개수

 1. 테이블 정의
    d[i][j] = j로 끝나는 경우의 i자리 이친수 개수 (경우의 수)
 2. 점화식 구하기
    d[i][0] = d[i-1][1]
    d[i][1] = d[i-1][0] + d[i-1][1]
 3. 초기값
    d[1][1] = 1, d[1][0] = 0
# 복잡도 검증
# 회고
*/


#include <bits/stdc++.h>
using namespace std;

int n;
long long d[100][2];

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;

    // INITIAL
    d[1][0] = 0, d[1][1] = 1;

    // LOOP: 점화식
    for (int i = 2; i <= 90; ++i) {
        d[i][0] = d[i-1][0] + d[i - 1][1];
        d[i][1] = d[i-1][0];
    }

    cout << d[n][0] + d[n][1];
}