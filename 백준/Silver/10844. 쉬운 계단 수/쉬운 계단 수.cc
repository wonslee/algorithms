/*
# 문제 재정의
 각 자릿수에 대한 경우의 수를 구해야 했다. 2차원 배열로 만들어야 한다.
 
 3자리를 만드는 과정을 떠올려보자.
 D[2][1] = 2
 앞에 2자리 중 마지막 자리 숫자에 따라서 가장 마지막 자리에 올 수 있는 숫자가 결정될 수 있는 것이다.
 예를들어 10, 34, 56, 89 라는 숫자인 상태에서 숫자 하나를 추가해서 3자리를 만든다고 생각해보자.
   10의 경우 2자리 중 마지막 자리 숫자인 0에 의해서 뒤에 올 수 있는 숫자는 1 하나 뿐이고
   12의 경우 2자리 중 마지막 자리 숫자인 2에 의해서 뒤에 올 수 있는 숫자는 1과 3 두개가 된다.
   32의 경우 2자리 중 마지막 자리 숫자인 2에 의해서 뒤에 올 수 있는 숫자는 1과 3 두개가 된다.
   34의 경우 2자리 중 마지막 자리 숫자인 4에 의해서 뒤에 올 수 있는 숫자는 3과 5 두개가 된다.
   56의 경우 5와 7이 있고, 9의 경우 8이 올 수 있다.
 - 즉, 만들어 놓은 수의 마지막 숫자에 의해서 그 다음에 올 수 있는 숫자들의 경우의 수가 정해지게 된다.
 마지막 전까지의 수들은 경우의 수에서 생각하지 않아도 된다.....?!
 
 단, 0과 9에 대한 조건을 더해줘야한다.
# 계획
 N=2일 때,
 D[2][0] = D[1][1]
 D[2][1] = D[1][0] + D[1][2]
 D[2][2] = D[1][1] + D[1][3]
 ...
 D[2][9] = D[1][8]
 1. 테이블 정의
    D[i][j] = i개의 숫자를 골랐을 때 마지막 자리가 j인 계단수 경우의 수 (j = 0~9)
 2. 점화식 구하기
    0이나 9가 아닐 경우 : D[i][j] = D[i-1][j-1] + D[i-1][j+1]
 3. 초기값
    D[1][1~9] = 1
# 복잡도 검증
 O(N) * 10
# 회고
 - DP 감 잡았다고 생각했는데, 아직 점화식 구하는 수준이 낮다.
 - 테이블 형태를 정하는 결정적인 분기를 생각해야 한다.
  이 문제의 경우 
*/


#include <bits/stdc++.h>
using namespace std;

int n;
long long d[101][10]; // 테이블

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;

    // INITIAL
    for (int i = 1; i <= 9; ++i) d[1][i] = 1;

    for (int i = 2; i <= n; ++i) {
        for (int k = 0; k <= 9; ++k) {
            // LOOP: 점화식
            if (k != 0) d[i][k] += d[i - 1][k - 1];
            if (k != 9) d[i][k] += d[i - 1][k + 1];
            d[i][k] %= 1000000000;
        }
    }
    long long ans = 0;
    for (int i = 0; i <= 9; ++i) {
        ans += d[n][i];
    }
    
    ans %= 1000000000;
    cout << ans;
}