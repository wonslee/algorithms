/*
# 문제 재정의
 경우의 수 문제.
 k/w
 9,12,15가 있다고 했을 때,
 27/3=9이므로 27까지도 들 수 있고,
 24/2=12이므로 12,15를 선택하여 24까지 들 수 있다.

 많이 선택할 수록 좋은건가? 아니다.
 로프를 선택할 때 ( 가장 작은 로프 * 선택한 로프 개수 ) 가 가장 큰 경우를 구해야 한다.

# 계획
 1. 우선 k의 각 로프를 중량순으로 정렬.
 2. 첫번째부터 순회하면서 현재 들 수 있는 최대 중량을 구해본다.
    k[1]*1, k[2]*2, k[3]*3, ...
 3. 갱신해나간다. 그렇지 않으면 종료
# 복잡도 검증
  O(n)
# 회고
 - 이게 그리디인건가?
 - DP나 백트래킹을 쓰는 방법은 없나
*/


#include <bits/stdc++.h>
using namespace std;

int n, ans;
int k[100004]; // 로프 배열

int main(void){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> k[i];
    }

    sort(k + 1, k + n + 1, greater<>());

    for (int i = 1; i <= n; ++i) {
        if (k[i] * i > ans) {
            ans = k[i] * i;
        }
    }

    cout << ans;
}