/*
# 문제 재정의
 - 특정 공간안에 가능한 적은 개체수를, 특정 기간동안 한 가지 이상 존재하도록 한다.
 - 회의 문제가 떠오른다. 그땐 회의 종료시간에 대해 정렬한 다음 종료 시간이 같다면 시작시간에 대해 정렬했음.
    그리고 현재 시각을 저장하는 변수와 비교해가면서 그때 이후의 회의를 선택했다.
    이 문제에서는 중간에 비는 시간이 있어선 안 되므로, '현재 시각'에서 얼마나 일찍이든지간에 일단 겹치는 놈을 고르고 봐야함. 늦게 끝날수록 좋고
 - 3월~11월의 날짜들을 선형적으로 나열하고 싶은데 배열을 쓰면 되려나?
 - 두 조건을 만족할 수 없는 경우를 체크해야만 한다. 가장 일찍 피는 꽃의 시작시간과 가장 마지막에 피는 꽃의 종료시간.

# 계획
 날짜에 대해선 pair을 쓰자.

 1. 끝나는 시각을 기준으로 오름차순 정렬
 2. 시작 시간이 유효한(3월 1일을 포함해야 함) 원소부터 시작. 만약 없다면 0 출력
    동시에 해당 원소의 종료 날짜를 현재 날짜에 할당
 3. 다음 놈을 고르는 기준은 현재 날짜보다 작은지 여부 && 종료 날짜가 가장 큰 놈
 4. 만약 11월 30일보다 작다면 0 출력

# 복잡도 검증
# 회고
 - 회의 문제 풀이에 너무 매몰되어있었다..
 - 시간(11월30일까지)을 기준으로 반복문을 돌리고, 그 안에서 배열 완전탐색을 하면 됐던 문제
 - 조건문은 같았다. 직전의 종료날짜보다 시작날짜가 작고, 베스트인 다음 날짜보다 종료날짜가 긴 놈을 찾아 베스트 날짜를 갱신해나가는 방법.
*/


#include <bits/stdc++.h>
using namespace std;
#define X first
#define Y second

int n;
int sm, sd, em, ed; // 시작 날짜와 종료 날짜
int t = 301; // 현재 시간
int ans = 0; // 선택한 꽃의 개수
vector<pair<int, int>> flower;

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;

    for (int i = 0; i < n; i++) {
        cin >> sm >> sd >> em >> ed;
        flower.push_back({sm * 100 + sd, em * 100 + ed}); // 날짜는 대충 파싱해도 됨
    }

    while (t < 1201) {// LOOP : 3월1일부터 11월 30일까지
        int nxt_t = t; // 이번에 추가할 꽃으로 인해 변경된 시간

        for(int i = 0; i < n; i++){// 배열 안에서 모두 탐색
            if(flower[i].X <= t && flower[i].Y > nxt_t) // CONDITION : 현재시간을 포함하되 가장 길게 유지되는 꽃
                nxt_t = flower[i].Y;
        }

        if(nxt_t == t){ // CONDITION : 시간 t에서 더 전진이 불가능한 경우.
            cout << 0;
            return 0;
        }

        ans++;
        t = nxt_t;
    }
    cout << ans;
}