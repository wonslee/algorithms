# 소수

소수 : 1과 자기 자신으로만 나눠지는 수 
= 약수가 딱 2개인 수 (=> 1은 소수가 아니다) 
= 2 ~ n-1 까지의 수로 나눠지지 않는 수

합성수 : 1과 자기 자신을 제외한 다른 약수를 갖는 수  

## 소수 찾는 시간복잡도 줄이기 : root(n)

> 합성수 N에서 1을 제외한 가장 작은 약수는 root(n) 이하이다.  

약수중에서 가장 큰 것은 root(n), 즉 완전제곱근이다.  
n=21일때 root(21) > 3 이고 3으로 나눠진다.  그 뒤에 7이 있고 없고는 크게 중요치 않음.   

## 소인수분해 (백준 11653)

```c++
int main(void){
  ios::sync_with_stdio(0);
  cin.tie(0);
  int n;
  cin >> n;
  for(int i = 2; i*i <= n; i++){
    while(n % i == 0){
      cout << i << '\n';
      n /= i;
    }
  }
  if(n != 1) cout << n;
}
```

사실 소수 개념보다도 while 문이 인상적이어서 씀.  
난 if문을 써서 매번 i를 줄이는.. 미개한 방식을 썼다.  
 **while도 어떻게 보면 조건문** 이다.  

만약 처음엔 조건문이라고 생각했는데 그 안에서 반복되어야 할게 있다면 while을 쓰자.  

## parametric search ?

